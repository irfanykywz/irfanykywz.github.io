{{ define "head" }}
  {{ partial "style.html" (dict "css" "css/files.css") }}
{{ end }}

{{ define "config" }}
    {{ .Scratch.Set "noIndex" true }} 
{{ end }}

{{ define "main" }}
	<main class="main">
		<div class="">

		<section class="">

<div class="file-manager-main">
    
    <header class="header-controls">
        <div>
            <h1>üìÅ {{ .Title }}</h1>
        </div>
        <div class="header-right">
            <button id="openEncryptTool" class="utility-button">üõ†Ô∏è Encrypt Tool</button>
            <div class="search-bar">
                <span class="search-icon">üîç</span>
                <input type="text" id="fileSearch" placeholder="Search files and folders..." />
            </div>
        </div>
    </header>
    
    <div class="filter-panel">
        <span class="filter-label">Filter by:</span>

        <select id="ownerFilter" class="filter-select">
            <option value="all">All Page</option>
            {{ $pages := .Data.Pages }}
            {{ range .Data.Pages }}    
                {{ $page := .Title }}
                <option value="{{ $page }}">{{ $page }}</option>
            {{ end }}
        </select>
        

        <select id="typeFilter" class="filter-select">
            <option value="all">All Types</option>
            {{ $allTypes := slice }}
            {{ range .Data.Pages }}
                {{ $files := .Params.files }}
                {{ range $files }}
                    {{ $allTypes = $allTypes | append .type }}
                {{ end }}
            {{ end }}
            
            {{ $uniqueTypes := uniq $allTypes }}
            
            {{ range sort $uniqueTypes }}
                <option value="{{ . }}">{{ . }}</option>
            {{ end }}
        </select>


        <button id="clearFilters" class="clear-filters-btn">
            <span class="icon">‚úñ</span> Clear Filters
        </button>
    </div>


    <div class="table-responsive">
        <div class="file-list-container" id="listView">
            <table class="table">
                <thead>
                    <tr>
                        <th class="col-name">Name</th>
                        <th class="col-owner">Page</th>
                        <th class="col-size">Size</th>
                        <th class="col-actions">Actions</th>
                    </tr>
                </thead>
                <tbody id="fileTableBody">
                    {{ $pages := .Data.Pages }}
                    {{ range .Data.Pages }}
    
                        {{ $page := .Title }}

                        {{ $files := .Params.files }}
                        {{ range $files }}
                            <tr 
                            class="file-item file {{ .type }}" 
                            data-owner="{{ $page }}" 
                            data-type="{{ .type }}" 
                            data-file-path="{{ .url }}" 
                            data-locked="{{ .lock }}" 
                            {{ if .lock }} data-salt="{{ .url }}" {{ end }}
                            {{ if .lock }} data-encrypted-content="{{ .url }}" {{ end }}>
                                <td class="col-name"><span class="icon pdf">üìÑ</span>{{ .name }}.{{ .type | lower }}</td>
                                <td class="col-owner">{{ $page }}</td>
                                <td class="col-size">{{ .size }}</td>
                                <td class="col-actions">
                                    {{ if .lock }}
                                    <span class="action-unlocked-group">
                                    {{ end }}
                                        <button class="action-button download-btn" title="Download">‚¨áÔ∏è</button>
                                        <button class="action-button copy-btn" title="Copy Path">üîó</button>
                                    {{ if .lock }}
                                    </span>
                                    <button class="action-button lock-btn" data-locked="true" title="Unlock File">üîí</button>
                                    {{ end }}
                                </td>
                            </tr>


                        {{ end }}
                    {{ end }}
                  
                </tbody>
            </table>
            
            <div id="noResultsMessage" class="no-results-message">
                <h2>No Files Found</h2>
                <p>We couldn't find any files matching your search or filters.</p>
                <p>Try clearing your filters or adjusting your search term.</p>
            </div>
            
        </div>
    </div>
    
    <div class="pagination-footer">
        <div class="pagination-controls">
            <span class="pagination-label">Items per page:</span>
            <select id="itemsPerPage" class="filter-select pagination-select">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">Show All</option>
            </select>
        </div>
        <div class="pagination-info">
            <span class="page-info" id="pageInfo">Showing 1-10 of 24 items</span>
            <button id="prevPage" class="page-button disabled">Previous</button>
            <div id="pageButtons" style="display:inline;">
                <!-- Page numbers will be injected here -->
            </div>
            <button id="nextPage" class="page-button">Next</button>
        </div>
    </div>
</div>

		</section>


		</div>

	</main>
{{ end }}

{{ define "footer" }}

<!-- Password Modal Structure -->
<div id="passwordModalOverlay" class="modal-overlay">
    <div class="modal-content-box password-modal">
        <h3>File Protection Required</h3>
        <p>Please enter the password to unlock actions for this file.</p>
        <input type="password" id="passwordInput" placeholder="Enter password" autocomplete="off" />
        <div id="passwordError" class="password-error"></div>
        <div class="modal-buttons">
            <button class="cancel-btn" id="modalCancel">Cancel</button>
            <button class="confirm-btn" id="modalConfirm">Unlock</button>
        </div>
    </div>
</div>

<!-- Encrypt Tool Modal Structure (With Close Button) -->
<div id="encryptModalOverlay" class="modal-overlay">
    <div class="modal-content-box encrypt-tool-modal">
        <h3>File Encryption Tool</h3>
        <form id="encryptForm">
            <div class="form-group">
                <label for="contentToEncrypt">Content to Encrypt (e.g., File Path or Secret Key)</label>
                <textarea id="contentToEncrypt" rows="4" placeholder="Enter the text content you want to encrypt" required></textarea>
            </div>
            <div class="form-group">
                <label for="encryptionKey">Encryption Key (Password)</label>
                <input type="text" id="encryptionKey" placeholder="Enter a secure password" required />
            </div>
            
            <div class="modal-buttons">
                <button class="cancel-btn" id="encryptModalClose2" type="button">Cancel</button>
                <button type="submit" class="encrypt-btn" id="encryptButton">Encrypt Content</button>
            </div>
        </form>
        
        <div id="encryptionResults" style="display: none; margin-top: 30px; border-top: 1px solid var(--border-color); padding-top: 20px;">
            <p style="font-size: 1.1em; color: var(--accent-secondary); margin-bottom: 15px;">Encryption Complete! Copy the values below.</p>

            <div class="output-group">
                <label>Url Encrypted (Copy this value)</label>
                <code id="outputUrl" title="Click to copy"></code>
                <span class="copy-message" id="urlCopyMessage">Copied!</span>
            </div>
            
            <div class="output-group" style="display:none;">
                <label>Data-Salt (Copy this value)</label>
                <code id="outputSalt" title="Click to copy"></code>
                <span class="copy-message" id="saltCopyMessage">Copied!</span>
            </div>

            <div class="output-group" style="display:none;">
                <label>Data-Encrypted-Content (Copy this value)</label>
                <code id="outputEncryptedContent" title="Click to copy"></code>
                <span class="copy-message" id="encryptedCopyMessage">Copied!</span>
            </div>
            
            <!-- CLOSE BUTTON ADDED HERE -->
            <div class="modal-buttons">
                <button class="cancel-btn" id="encryptModalClose">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Load Crypto-JS Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const fileSearch = document.getElementById('fileSearch');
        const typeFilter = document.getElementById('typeFilter');
        const ownerFilter = document.getElementById('ownerFilter');
        const clearFiltersBtn = document.getElementById('clearFilters');
        const fileTableBody = document.getElementById('fileTableBody');
        const noResultsMessage = document.getElementById('noResultsMessage'); 
        const itemsPerPageSelect = document.getElementById('itemsPerPage');
        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');
        const pageButtonsContainer = document.getElementById('pageButtons');
        const pageInfoSpan = document.getElementById('pageInfo');

        // Decryption Modal Elements
        const passwordModalOverlay = document.getElementById('passwordModalOverlay');
        const passwordInput = document.getElementById('passwordInput');
        const passwordError = document.getElementById('passwordError');
        const modalCancel = document.getElementById('modalCancel');
        const modalConfirm = document.getElementById('modalConfirm');
        
        // Encryption Modal Elements
        const openEncryptToolBtn = document.getElementById('openEncryptTool');
        const encryptModalOverlay = document.getElementById('encryptModalOverlay');
        const encryptModalClose = document.getElementById('encryptModalClose'); 
        const encryptModalClose2 = document.getElementById('encryptModalClose2'); 
        const encryptForm = document.getElementById('encryptForm');
        const contentToEncrypt = document.getElementById('contentToEncrypt');
        const encryptionKey = document.getElementById('encryptionKey');
        const encryptionResultsDiv = document.getElementById('encryptionResults');
        const outputUrl = document.getElementById('outputUrl');
        const outputSalt = document.getElementById('outputSalt');
        const outputEncryptedContent = document.getElementById('outputEncryptedContent');
        const urlCopyMessage = document.getElementById('urlCopyMessage');
        const saltCopyMessage = document.getElementById('saltCopyMessage');
        const encryptedCopyMessage = document.getElementById('encryptedCopyMessage');

        const HARDCODED_PASSWORD = '1234'; 
        let currentPage = 1;
        let itemsPerPage = 10;
        let allFileItems = Array.from(fileTableBody.querySelectorAll('.file-item'));
        let currentFileToUnlock = null; 

        // --- CRYPTO-JS DECRYPTION FUNCTIONS ---

        // Function 1: Derive key using PBKDF2 with salt
        function hashFormatDecrypt(password, salt) {
            // t is password, e is salt
            return CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1e3 }).toString();
        }

        // Function 2: Authenticate and decrypt
        function decrypt(key, encryptedData) {
            // t is key (derivedKey), e is encryptedData
            try {
                // r: HMAC (first 64 hex chars)
                var r = encryptedData.substring(0, 64); 
                // n: Ciphertext + Salted_ + IV (remaining string)
                var n = encryptedData.substring(64); 
                
                // Validate HMAC (Integrity check)
                const calculatedHmac = CryptoJS.HmacSHA256(n, CryptoJS.SHA256(key).toString()).toString();

                if (calculatedHmac === r) {
                    return decryptMsg(n, key);
                }
                return null; // HMAC mismatch
            } catch (e) {
                console.error("Decryption utility error:", e);
                return null;
            }
        }

        // Function 3: Perform actual AES decryption
        function decryptMsg(encryptedMsg, key) {
            // t is encryptedMsg (Ciphertext + Salted_ + IV), e is key
            // The provided function logic is slightly custom/compact, using AES.decrypt
            // and assuming the first 32 hex chars of the message are the IV.
            var r = CryptoJS.enc.Hex.parse(encryptedMsg.substr(0, 32)); // IV
            var n = encryptedMsg.substring(32); // Ciphertext
            
            return CryptoJS.AES.decrypt(n, key, {
                iv: r, 
                padding: CryptoJS.pad.Pkcs7, 
                mode: CryptoJS.mode.CBC
            }).toString(CryptoJS.enc.Utf8);
        }

        // --- CRYPTO-JS ENCRYPTION FUNCTIONS (New) ---
        
        // Function 4: Derive key using PBKDF2 and generate a random salt
        function hashFormatEncrypt(key) {
            var salt = CryptoJS.lib.WordArray.random(128 / 8).toString();

            var hashKey = CryptoJS.PBKDF2(key, salt, {
                keySize: 256 / 32,
                iterations: 1000
            });

            return {
                salt: salt,
                hashKey: hashKey.toString(),
            };
        }

        // Function 5: Encrypt message using AES, generating a random IV
        function encrypt(msg, key) {
            var iv = CryptoJS.lib.WordArray.random(128 / 8);

            var encrypted = CryptoJS.AES.encrypt(msg, key, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC
            });
            // Return IV + Ciphertext (This is 'n' in the decryption process)
            return iv.toString() + encrypted.toString(); 
        }

        // ADDED: Function to handle closing on overlay click
        function handleOverlayClick(event, closeFn) {
            // Only close if the click target is the overlay itself (and not the content box inside it)
            if (event.target.classList.contains('modal-overlay')) {
                closeFn();
            }
        }

        // --- DECRYPTION MODAL CONTROL LOGIC ---

        function openDecryptModal(fileRow) {
            currentFileToUnlock = fileRow;
            passwordInput.value = '';
            passwordError.textContent = '';
            passwordModalOverlay.classList.add('open');
            passwordInput.focus();
        }

        function closeDecryptModal() {
            passwordModalOverlay.classList.remove('open');
            currentFileToUnlock = null;
            passwordInput.value = '';
        }

        function handlePasswordAttempt() {
            if (!currentFileToUnlock) return;

            const enteredPassword = passwordInput.value;
            passwordError.textContent = '';
            
            const fileSalt = currentFileToUnlock.getAttribute('data-salt');
            const encryptedContent = currentFileToUnlock.getAttribute('data-encrypted-content');
            
            // Handle simple locked files (for mock purposes)
            // if (!fileSalt || !encryptedContent) {
            //     if (enteredPassword === '1234') { 
            //         currentFileToUnlock.setAttribute('data-locked', 'false');
            //         updateLockButton(currentFileToUnlock, false);
            //         closeDecryptModal();
            //     } else {
            //         passwordError.textContent = 'Incorrect password. (Hint: Try "1234" for simple files)';
            //     }
            //     return;
            // }

            try {
                // 1. Derive the key using the password and the file's salt
                const derivedKey = hashFormatDecrypt(enteredPassword, fileSalt.split(',')[0]); 
                
                // 2. Decrypt the content using the derived key
                const decryptedResult = decrypt(derivedKey, encryptedContent.split(',')[1]);

                if (decryptedResult !== null && decryptedResult !== "") {
                    // Success!
                    currentFileToUnlock.setAttribute('data-locked', 'false');
                    currentFileToUnlock.setAttribute('data-file-path', decryptedResult);
                    updateLockButton(currentFileToUnlock, false);
                    closeDecryptModal();
                } else {
                    passwordError.textContent = 'Incorrect password/key. (Hint: "year when the world ?")';
                    passwordInput.focus();
                }
            } catch(e) {
                console.error('Decryption error:', e);
                passwordError.textContent = 'An error occurred during decryption.';
            }
        }
        
        function updateLockButton(fileRow, isLocked) {
             const lockButton = fileRow.querySelector('.lock-btn');
            if(lockButton) {
                lockButton.setAttribute('data-locked', isLocked.toString());
                lockButton.title = isLocked ? 'Unlock File' : 'Lock File';
                lockButton.textContent = isLocked ? 'üîí' : 'üîì';
            }
        }
        
        // Decryption Modal Listeners
        modalCancel.addEventListener('click', closeDecryptModal);
        modalConfirm.addEventListener('click', handlePasswordAttempt);
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handlePasswordAttempt();
            }
        });

        // ADDED: Overlay close listener
        passwordModalOverlay.addEventListener('click', (e) => handleOverlayClick(e, closeDecryptModal));

        // --- ENCRYPTION MODAL CONTROL LOGIC ---

        function openEncryptModal() {
            // Reset form and results view
            encryptForm.reset();
            encryptionResultsDiv.style.display = 'none';
            outputSalt.textContent = '';
            outputEncryptedContent.textContent = '';
            encryptModalOverlay.classList.add('open');
            contentToEncrypt.focus();
        }

        function closeEncryptModal() {
            encryptModalOverlay.classList.remove('open');
        }
        
        function handleCopy(e) {
            const targetCode = e.currentTarget;
            const textToCopy = targetCode.textContent;
            const copyMessageId = targetCode.id === 'outputSalt' ? 'saltCopyMessage' : targetCode.id === 'outputUrl' ? 'urlCopyMessage' : 'encryptedCopyMessage';
            const copyMessageEl = document.getElementById(copyMessageId);
            
            if (!textToCopy) return;

            try {
                // Use document.execCommand for robust copying in all environments (like iframes)
                const tempInput = document.createElement('input');
                tempInput.value = textToCopy;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                // Show copy confirmation
                copyMessageEl.classList.add('show');
                setTimeout(() => copyMessageEl.classList.remove('show'), 1000);

            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            e.stopPropagation();
        }

        encryptForm.addEventListener('submit', function (e) {
            e.preventDefault();

            const content = contentToEncrypt.value;
            const key = encryptionKey.value;
            
            if (!content || !key) return;

            try {
                // 1. Generate salt and hash key using PBKDF2
                var goHash = hashFormatEncrypt(key);
                var hashKey = goHash.hashKey;
                var salt = goHash.salt;

                // 2. Encrypt the content (result is IV + Ciphertext)
                var encryptedMsgPart = encrypt(content, hashKey);
                
                // 3. Create the HMAC (Integrity check)
                var hmac = CryptoJS.HmacSHA256(encryptedMsgPart, CryptoJS.SHA256(hashKey).toString()).toString();
                
                // 4. Combine into final encrypted message (HMAC + IV + Ciphertext)
                var encryptedMsg = hmac + encryptedMsgPart;
                
                // Display results
                outputUrl.textContent = `${salt},${encryptedMsg}`;
                outputSalt.textContent = salt;
                outputEncryptedContent.textContent = encryptedMsg;
                encryptionResultsDiv.style.display = 'block';

            } catch (error) {
                console.error("Encryption Error:", error);
                // Use custom modal or message box instead of alert()
                // For simplicity here, we'll log, but normally this would be a UI notification.
                alert('Encryption failed. Check console for details.'); 
            }
        });
        
        // Encrypt Modal Listeners
        openEncryptToolBtn.addEventListener('click', openEncryptModal);
        encryptModalClose.addEventListener('click', closeEncryptModal);
        encryptModalClose2.addEventListener('click', closeEncryptModal);
        // ADDED: Overlay close listener
        encryptModalOverlay.addEventListener('click', (e) => handleOverlayClick(e, closeEncryptModal));
        
        outputUrl.addEventListener('click', handleCopy);
        outputSalt.addEventListener('click', handleCopy);
        outputEncryptedContent.addEventListener('click', handleCopy);        

        // --- ACTION HANDLERS ---
        function handleDownload(e) {
            const row = e.target.closest('.file-item');
            const filePath = row.getAttribute('data-file-path');
            const fileName = row.querySelector('.col-name').textContent.trim();

            if (row.getAttribute('data-locked') === 'true') {
                // Should be hidden, but as a safeguard:
                return openDecryptModal(row);
            }
            
            // Check if the file path is a data URI for HTML
            if (filePath.startsWith('data:text/html,')) {
                try {
                    // Extract and decode the content
                    const encodedContent = filePath.split(',')[1];
                    const decodedContent = decodeURIComponent(encodedContent);

                    // Create a Blob from the decoded content
                    const blob = new Blob([decodedContent], { type: 'text/html' });

                    // Create a temporary URL for the Blob
                    const blobUrl = URL.createObjectURL(blob);

                    // Open the Blob URL in a new window
                    const newWindow = window.open(blobUrl, '_blank', 'noopener,noreferrer');

                    // Handle memory cleanup after the window is loaded
                    if (newWindow) {
                        newWindow.addEventListener('load', () => {
                            URL.revokeObjectURL(blobUrl);
                        }, { once: true });
                    } else {
                        console.log('Popup blocked. Please enable popups for this site.');
                    }
                } catch (error) {
                    console.error('Failed to handle data:text/html URI:', error);
                    console.log('Error opening content. See console for details.');
                }
            } else {
                // Handle regular file paths
                window.open(filePath, '_blank', 'noopener,noreferrer');
            }

            e.stopPropagation();
        }

        async function handleCopyPath(e) {
            const button = e.target.closest('.copy-btn');
            const row = e.target.closest('.file-item');
            const filePath = row.getAttribute('data-file-path');
            
            if (row.getAttribute('data-locked') === 'true') {
                 // Should be hidden, but as a safeguard:
                 return openDecryptModal(row);
            }

            const originalText = button.textContent;
            
            if (filePath && navigator.clipboard && button) {
                try {
                    await navigator.clipboard.writeText(filePath);
                    
                    button.textContent = 'Copied!';
                    button.classList.add('copied-success');

                    setTimeout(() => {
                        button.textContent = originalText;
                        button.classList.remove('copied-success');
                    }, 1500);

                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    alert('Copy failed! Browser clipboard access blocked.');
                }
            }
            e.stopPropagation(); 
        }

        function handleLockUnlock(e) {
            const button = e.target.closest('.lock-btn');
            const row = e.target.closest('.file-item');
            
            const isLocked = row.getAttribute('data-locked') === 'true';

            if (isLocked) {
                // If currently locked, ask for password to unlock
                openDecryptModal(row);
            } else {
                // If currently unlocked, lock it instantly
                row.setAttribute('data-locked', 'true');
                button.setAttribute('data-locked', 'true');
                button.title = 'Unlock File';
                button.textContent = 'üîí'; // Locked symbol
            }
            e.stopPropagation();
        }        


        // --- FILTER AND PAGINATION CORE LOGIC (Using functional array methods for efficiency) ---
        function getFilteredItems() {
            const searchTerm = fileSearch.value.toLowerCase();
            const selectedType = typeFilter.value;
            const selectedOwner = ownerFilter.value;

            return allFileItems.filter(item => {
                const itemName = item.querySelector('.col-name').textContent.toLowerCase();
                const itemType = item.getAttribute('data-type');
                const itemOwner = item.getAttribute('data-owner');

                if (searchTerm && !itemName.includes(searchTerm)) { return false; }
                if (selectedType !== 'all' && itemType !== selectedType) { return false; }
                if (selectedOwner !== 'all' && itemOwner !== selectedOwner) { return false; }
                
                return true;
            });
        }

        function renderPaginationControls(totalItems) {
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            pageButtonsContainer.innerHTML = '';
            
            const maxButtons = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxButtons - 1);

            if (endPage - startPage < maxButtons - 1) {
                startPage = Math.max(1, endPage - maxButtons + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.classList.add('page-button');
                if (i === currentPage) {
                    button.classList.add('active');
                }
                button.addEventListener('click', () => {
                    currentPage = i;
                    applyFiltersAndPagination();
                });
                pageButtonsContainer.appendChild(button);
            }
            
            prevPageBtn.classList.toggle('disabled', currentPage === 1);
            nextPageBtn.classList.toggle('disabled', currentPage === totalPages || totalPages === 0);
        }

        function updatePageInfo(totalItems, currentCount) {
             if (itemsPerPage === 'all') {
                pageInfoSpan.textContent = `Showing all ${totalItems} items`;
            } else if (totalItems === 0) {
                 pageInfoSpan.textContent = `No items found`;
            } else {
                const start = (currentPage - 1) * itemsPerPage + 1;
                const end = Math.min(start + currentCount - 1, totalItems);
                pageInfoSpan.textContent = `Showing ${start}-${end} of ${totalItems} items`;
            }
        }
        
        function applyFiltersAndPagination() {
            const filteredItems = getFilteredItems();
            const totalItems = filteredItems.length;
            const table = fileTableBody.parentNode;
            
            const isFilterActive = fileSearch.value !== '' || typeFilter.value !== 'all' || ownerFilter.value !== 'all';
            clearFiltersBtn.classList.toggle('is-active', isFilterActive);
            
            if (totalItems === 0) {
                table.style.display = 'none';
                noResultsMessage.style.display = 'block';
                document.querySelector('.pagination-footer').style.display = 'none';
                return;
            } else {
                table.style.display = 'table';
                noResultsMessage.style.display = 'none';
                document.querySelector('.pagination-footer').style.display = 'flex';
            }

            let effectiveItemsPerPage = itemsPerPage;
            let isShowingAll = effectiveItemsPerPage === 'all';
            if (isShowingAll) {
                currentPage = 1;
                effectiveItemsPerPage = totalItems || 1;
            }

            const totalPages = Math.ceil(totalItems / effectiveItemsPerPage);
            if (currentPage > totalPages && totalPages > 0) { currentPage = totalPages; }
            
            const startIndex = (currentPage - 1) * effectiveItemsPerPage;
            const endIndex = Math.min(startIndex + effectiveItemsPerPage, totalItems);
            const itemsToShow = filteredItems.slice(startIndex, endIndex);

            let currentCount = 0;

            allFileItems.forEach(item => {
                if (itemsToShow.includes(item)) {
                    item.style.display = 'table-row';
                    currentCount++;
                } else {
                    item.style.display = 'none';
                }
            });
            
            const paginationFooter = document.querySelector('.pagination-footer');
            const paginationInfo = document.querySelector('.pagination-info');

            if (isShowingAll) {
                 paginationInfo.style.display = 'none';
            } else {
                paginationInfo.style.display = 'inline-flex';
                renderPaginationControls(totalItems);
                updatePageInfo(totalItems, currentCount);
            }
            paginationFooter.style.display = 'flex';
        }

        // --- NEW: URL Query Search Logic ---
        function checkUrlQueryAndSearch() {
            const urlParams = new URLSearchParams(window.location.search);
            const query = urlParams.get('q');
            
            if (query) {
                // Decode the URI component to handle spaces and special characters correctly
                const decodedQuery = decodeURIComponent(query.replace(/\+/g, ' '));
                
                // 1. Update the search input field
                fileSearch.value = decodedQuery;
                
                // 2. Reset filters for a clean search view (optional, but good practice)
                typeFilter.value = 'all';
                ownerFilter.value = 'all';
                itemsPerPageSelect.value = '10';
                itemsPerPage = 10;
                currentPage = 1;

                console.log(`Auto-populating search with query from URL: "${decodedQuery}"`);
            }
        }


        // --- Event Listeners Initialization ---       
        fileTableBody.addEventListener('click', (e) => {
            if (e.target.classList.contains('download-btn')) {
                handleDownload(e);
            } else if (e.target.classList.contains('copy-btn')) {
                handleCopyPath(e);
            } else if (e.target.closest('.lock-btn')) {
                handleLockUnlock(e);
            }
        });


        itemsPerPageSelect.addEventListener('change', () => {
            itemsPerPage = itemsPerPageSelect.value === 'all' ? 'all' : parseInt(itemsPerPageSelect.value);
            currentPage = 1;
            applyFiltersAndPagination();
        });

        prevPageBtn.addEventListener('click', () => {
            if (currentPage > 1 && itemsPerPage !== 'all') {
                currentPage--;
                applyFiltersAndPagination();
            }
        });

        nextPageBtn.addEventListener('click', () => {
            const totalItems = getFilteredItems().length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            if (currentPage < totalPages && itemsPerPage !== 'all') {
                currentPage++;
                applyFiltersAndPagination();
            }
        });

        fileSearch.addEventListener('keyup', () => { currentPage = 1; applyFiltersAndPagination(); });
        typeFilter.addEventListener('change', () => { currentPage = 1; applyFiltersAndPagination(); });
        ownerFilter.addEventListener('change', () => { currentPage = 1; applyFiltersAndPagination(); });

        clearFiltersBtn.addEventListener('click', () => {
            fileSearch.value = '';
            typeFilter.value = 'all';
            ownerFilter.value = 'all';
            currentPage = 1;
            if(itemsPerPageSelect.value === 'all') {
                itemsPerPageSelect.value = '10'; 
                itemsPerPage = 10;
            }
            applyFiltersAndPagination();
        });
        
        // 1. Check if a query exists in the URL
        checkUrlQueryAndSearch(); 
        // 2. Apply filters and pagination (this executes the search if a query was found)
        applyFiltersAndPagination();
    });
</script>

{{ end }}